package com.ssafy.ws02.step3;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Solution {

	public static void main(String[] args) throws NumberFormatException, IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(br.readLine());
		String[]ans=new String[T];	//정답 배열
		
		for (int tc = 1; tc <= T; tc++) {
			int N = Integer.parseInt(br.readLine());	//배열크기 입력
			char[][] map = new char[N][N];
			int maxh = 2;	//전체 빌딩 중 최대 높이.2로 초기화.
			
			for (int i = 0; i < N; i++) { // 입력
				StringTokenizer st = new StringTokenizer(br.readLine()," ");	//구분자:공백
				for(int j=0; j<N; j++) {
					 map[i][j]=st.nextToken().charAt(0);
				}
			}

			for (int i = 0; i < N; i++) { // 탐색 시작
				for (int j = 0; j < N; j++) {
					boolean canBuild = false;	//인접한 곳에 'G'가 없으면 true
					if (map[i][j] == 'B') {// B를 만났을때. 8방향 탐색
						if (i - 1 >= 0 && map[i - 1][j] == 'G') {	//상	
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						} 
						else if (i - 1 >= 0 && j - 1 >= 0 && map[i - 1][j - 1] == 'G') {	//좌상
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						}
						else if (j - 1 >= 0 && map[i][j - 1] == 'G') {	//좌							
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						} 
						else if (i + 1 < N && j - 1 >= 0 && map[i + 1][j - 1] == 'G') {		//좌하					
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						} 
						else if (i + 1 < N && map[i + 1][j] == 'G') {	//하						
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						} 
						else if (i + 1 < N && j + 1 < N && map[i + 1][j + 1] == 'G') {	//우하						
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						} 
						else if (j + 1 < N && map[i][j + 1] == 'G') {	//우
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						}
						else if (i - 1 >= 0 && j + 1 < N && map[i - 1][j + 1] == 'G') {	//우상
							continue;	// 방향 탐색 끝. 다음 'B'를 찾아서..
						}
						//if문을 모두 통과했다면
						canBuild = true;
						
						if (canBuild == true) { // 빌딩 세우기 가능하다면
							// 여기서 지을 수 있는 빌딩 높이 구하기.
							int tmph = 0;	//이 자리에서 지을수 있는 높이
							for (int k = 0; k < N; k++) {
								if (map[i][k] == 'B') {
									tmph++;
								}
								if (map[k][j] == 'B') {
									tmph++;
								}
							}
							tmph--; // 자기 자신 두번 더함. 한번 빼자.
							
							if (tmph > maxh) {	//현재까지 최대높이보다 크다면 갱신,
								maxh = tmph;
							}
						}

					}

				}
			}
			ans[tc-1]="#"+tc+" "+maxh;

		}
		for(int i=0; i<T; i++) {
			System.out.println(ans[i]);
		}
	}

}

/*
 * 구획 당 하나의 빌딩을 세울 수 있고, 빌딩을 세울 수 있는 구획은 B 로 표시, 공원 조성단지는 G 로 표시되어 있다. 빌딩을 세울 때
 * 인접한 구획에 공원 조성 단지 G 가 있다면 2 층 높이로 세울 수 있고, 인접한 구획에 공원 조성 단지 G 가 없다면 현 위치의 가로
 * 위치에 있는 빌딩구획 B 와 세로 위치의 빌딩 구획 B 의 수를 더한 크기만큼 빌딩을 세울 수 있다. 가장 높이 세울 수 있는 빌딩은 몇
 * 층인가?
 */
